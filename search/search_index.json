{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Wimsey \ud83d\udd0d","text":"<p>A fast, lightweight and easy data contract library.</p> <p>Ideally, all data would be usable when you recieve it, but you probably already have figured that's not always the case. That's where data contracts come in.</p> <p>A data contract is an expression of what should be true of some data, such as that it should 'only have columns x and y' or 'the values of column a should never exceed 1'. Wimsey is a library built to run these contracts on a dataframe during python runtime.</p> <p>Wimsey is built on top of the awesome Narwhals and natively supports any dataframes that Narwhal's does. At the time of writing, that includes Polars, Pandas, Arrow, Dask, Rapids and Modin.</p>"},{"location":"#run-through","title":"Run through","text":"<p>As an example, let's work through a simple example, and imagine we recieve \"top-6-sleuths.csv\" daily, over sftp. It's meant to look something like this:</p> first_name last_name rating cases_solved Peter Wimsey 9 11 Jane Marple 9 12 Father Brown 7 53 Hercule Poirot 10 33 Beatrice Bradley 8 66 <p>It's meant to contain the top 5 sleuths, only sometimes, it has the wrong number of entries; othertimes first names are missing; and whilst ratings should be out of 10, sometimes they are over that. To make things worse every now and then, someone puts \"lots\" into <code>cases_solved</code> meaning it's no longer a number, and that causes all kinds of trouble.</p>"},{"location":"#writing-tests","title":"Writing Tests","text":"<p>We can convert those concerns we just mentioned into four tests to carry out on our dataset:</p> <ul> <li>The row count should be 5</li> <li><code>first_name</code> should never be null</li> <li><code>rating</code> should be be less than 10</li> <li><code>cases_solved</code> should be a number</li> </ul> <p>We can test for a lot more than that, but that works for our example. Our first move is to write this out as a \"contract\". This can be a yaml or json file, or alternatively, we can code it directly into python.</p> sleuth-checks.yamlsleuth-checks.jsonsleuth_checks.py <pre><code>- test: row_count_should\nbe_exactly: 5\n- column: first_name\ntest: null_percentage_should\nbe_exactly: 0\n- column: rating\ntest: max_should\nbe_less_than_or_equal_to: 10\n- column: cases_solved\ntest: type_should\nbe_one_of:\n- int64\n- float64\n</code></pre> <p>Note you'll need <code>pyyaml</code> installed to support reading yaml</p> <pre><code>[\n{\n\"test\": \"row_count_should\",\n\"be_exactly\": 5\n},\n{\n\"column\": \"first_name\",\n\"test\": \"null_percentage_should\",\n\"be_exactly\": 0\n},\n{\n\"column\": \"rating\",\n\"test\": \"max_should\",\n\"be_less_than_or_equal_to\": 10\n},\n{\n\"column\": \"cases_solved\",\n\"test\": \"type_should\",\n\"be_one_of\": [\"int64\", \"float64\"]\n]\n</code></pre> <pre><code>from wimsey import tests\nchecks = [\ntests.row_count_should(be_exactly=5),\ntests.null_percentage_should(column=\"first_name\", be_exactly=0),\ntests.max_should(column=\"rating\", be_less_than_or_equal_to=10),\ntests.type_should(column=\"cases_solved\", be_one_of=[\"int64\", \"float64]),\n]\n</code></pre> <p>See Possible Tests for a full catalogue of runnable tests and their configurations.</p>"},{"location":"#executing-tests","title":"Executing Tests","text":"<p>Now that we've written out tests, we just need to actually run them on the actual data. There's two functions <code>wimsey</code> gives you to carry out checks: <code>validate</code> and <code>test</code>. These both carry out checks in the same way, but behave slightly differently based on the results.</p> <ul> <li><code>test</code> will return a <code>FinalResult</code> type of object. It's a dataclasses containing a <code>success</code> boolean, alongside further details on the individual tests in a <code>results</code> lists.</li> <li><code>validate</code> will run the checks and then just return the initial dataframe assuming everything passed. If any tests failed, it'll stop execution and throw a <code>DataValidationException</code>.</li> </ul> <p>These are designed to cover a couple different use cases, <code>test</code> will provide more details if you want to dig into problems in a dataset, whilst <code>validate</code> is helpful if you just want to use <code>wimsey</code> as a \"guard\" to catch bad data from being processed.</p> <p>We'll cover <code>test</code> first, it's called the same regardless of what type your dataframe is:</p> using sleuth-checks.yamlusing sleuth-checks.jsonusing sleuth_checks.py <pre><code>from wimsey import test\nresult = test(df, contract=\"sleuth-checks.yaml\")\nif result.success:\nprint(\"Everything is as expected! \ud83d\ude4c\")\nelse:\nprint(\"Uh-oh, something's up! \ud83d\ude2c\")\nprint([i for i in result.results if not i.success])\n</code></pre> <p>Note you'll need <code>pyyaml</code> installed to support reading yaml</p> <pre><code>from wimsey import test\nresult = test(df, contract=\"sleuth-checks.json\")\nif result.success:\nprint(\"Everything is as expected! \ud83d\ude4c\")\nelse:\nprint(\"Uh-oh, something's up! \ud83d\ude2c\")\nprint([i for i in result.results if not i.success])\n</code></pre> <pre><code>from wimsey import test\nfrom sleuth_checks import checks\nresult = test(df, contract=checks)\nif result.success:\nprint(\"Everything is as expected! \ud83d\ude4c\")\nelse:\nprint(\"Uh-oh, something's up! \ud83d\ude2c\")\nprint([i for i in result.results if not i.success])\n</code></pre> <p>Wimsey uses fsspec under the hood, so configs can be from any filesystem supported by fsspec (such as S3, SSH, Azure, Google Cloud etc) - use the fsspec prefix and pass in the appropriate storage options using <code>test</code>'s <code>storage_options</code> keyword. See fsspec documentation for more details on this.</p> <p>Validate, will run tests in the exact same way as <code>test</code>, but simply raises an error if data fails expectations. This, in conjunction with Wimsey's compatibility with multiple dataframe types can make it a convenient tool for providing guarantees in a data pipeline.</p> pandaspolarsdaskpyarrow <pre><code>import pandas as pd\nfrom wimsey import validate\nfrom settings import sleuth_storage_options\ntop_sleuth: str = (\npd.read_csv(\n\"sshfs://sleuthwatch/top-5-sleuths.csv\",\nstorage_options=sleuth_storage_options,\n)\n.pipe(validate, \"sleuth-checks.json\")  # &lt;- this is the wimsey bit\n.assign(name=lambda df: df[\"first_name\"] + df[\"last_name\"])\n.sort_values(\"rating\", ascending=False)\n[\"name\"][0]\n)\nprint(f\"{top_sleuth} is the best sleuth!\")\n</code></pre> <pre><code>import polars as pl\nfrom wimsey import validate\nfrom settings import sleuth_storage_options\ntop_sleuth: str = (\npl.read_csv(\n\"sshfs://sleuthwatch/top-5-sleuths.csv\",\nstorage_options=storage_options,\n)\n.pipe(validate, \"sleuth-checks.json\")  # &lt;- this is the wimsey bit\n.with_columns(name=pl.col(\"first_name\") + \" \" + pl.col(\"last_name\"))\n.sort(\"rating\", descending=True)\n.select(\"name\")\n.to_series()[0]\n)\nprint(f\"{top_sleuth} is the best sleuth!\")\n</code></pre> <pre><code>import dask.dataframe as dd\nfrom wimsey import validate\nfrom settings import sleuth_storage_options\ntop_sleuth: str = (\ndd.read_csv(\n\"sshfs://sleuthwatch/top-5-sleuths.csv\",\nstorage_options=sleuth_storage_options,\n)\n.pipe(validate, \"sleuth-checks.json\")  # &lt;- this is the wimsey bit\n.assign(name=lambda df: df[\"first_name\"] + \" \" + df[\"last_name\"])\n.sort_values(\"rating\", ascending=False)\n[\"name\"]\n.compute()[0]\n)\nprint(f\"{top_sleuth} is the best sleuth!\")\n</code></pre> <pre><code>from pyarrow import compute, csv\nfrom wimsey import validate\nfrom settings import download_sleuth_file\ndownload_sleuth_file(to=\"local-5-sleuths.csv\")\ndf = csv.read_csv(\"local-5-sleuths.csv\")\nvalidate(df, \"sleuth-checks.json\")  # &lt;- this is the wimsey bit\nname = compute.binary_join_element_wise(df[\"first_name\"], df[\"last_name\"], \" \")\ndf = df.append(\"name\", name).sort_by(\"rating\")\ntop_sleuth = str(df[\"name\"][-1])\nprint(f\"{top_sleuth} is the best sleuth!\")\n</code></pre> <p>And that's it, to keep things simple <code>validate</code> and <code>test</code> are the only public-intended functions in Wimsey, aside from test creation, which is covered further in the possible tests section.</p>"},{"location":"possible_tests/","title":"Possible Tests \ud83e\uddea","text":"<p>This documentation is intended as an exaustive list of possible tests within Wimsey. Note that examples given intentionally use all possible keywords for demonstrative purposes. This isn't required, and you can give as many or as few keywords as you like with the exception of where <code>column</code> is required.</p>"},{"location":"possible_tests/#mean_should","title":"mean_should","text":"<p>Test that column mean is within designated range</p> yamljsonpython <pre><code>be_exactly: 300\nbe_greater_than: 500\nbe_greater_than_or_equal_to: 500\nbe_less_than: 500\nbe_less_than_or_equal_to: 300\ncolumn: column_a\n</code></pre> <pre><code>{\n\"column\": \"column_a\",\n\"be_exactly\": 300,\n\"be_less_than\": 500,\n\"be_less_than_or_equal_to\": 300,\n\"be_greater_than\": 500,\n\"be_greater_than_or_equal_to\": 500\n}\n</code></pre> <pre><code>from wimsey import test\nfrom wimsey.tests import mean_should\nkeywords = {\n\"column\": \"column_a\",\n\"be_exactly\": 300,\n\"be_less_than\": 500,\n\"be_less_than_or_equal_to\": 300,\n\"be_greater_than\": 500,\n\"be_greater_than_or_equal_to\": 500\n}\nresult = test(df, contract=[mean_should(**keywords)])\n</code></pre>"},{"location":"possible_tests/#min_should","title":"min_should","text":"<p>Test that column min is within designated range</p> yamljsonpython <pre><code>be_exactly: 300\nbe_greater_than: 500\nbe_greater_than_or_equal_to: 500\nbe_less_than: 500\nbe_less_than_or_equal_to: 300\ncolumn: column_a\n</code></pre> <pre><code>{\n\"column\": \"column_a\",\n\"be_exactly\": 300,\n\"be_less_than\": 500,\n\"be_less_than_or_equal_to\": 300,\n\"be_greater_than\": 500,\n\"be_greater_than_or_equal_to\": 500\n}\n</code></pre> <pre><code>from wimsey import test\nfrom wimsey.tests import min_should\nkeywords = {\n\"column\": \"column_a\",\n\"be_exactly\": 300,\n\"be_less_than\": 500,\n\"be_less_than_or_equal_to\": 300,\n\"be_greater_than\": 500,\n\"be_greater_than_or_equal_to\": 500\n}\nresult = test(df, contract=[min_should(**keywords)])\n</code></pre>"},{"location":"possible_tests/#max_should","title":"max_should","text":"<p>Test that column max is within designated range</p> yamljsonpython <pre><code>be_exactly: 300\nbe_greater_than: 500\nbe_greater_than_or_equal_to: 500\nbe_less_than: 500\nbe_less_than_or_equal_to: 300\ncolumn: column_a\n</code></pre> <pre><code>{\n\"column\": \"column_a\",\n\"be_exactly\": 300,\n\"be_less_than\": 500,\n\"be_less_than_or_equal_to\": 300,\n\"be_greater_than\": 500,\n\"be_greater_than_or_equal_to\": 500\n}\n</code></pre> <pre><code>from wimsey import test\nfrom wimsey.tests import max_should\nkeywords = {\n\"column\": \"column_a\",\n\"be_exactly\": 300,\n\"be_less_than\": 500,\n\"be_less_than_or_equal_to\": 300,\n\"be_greater_than\": 500,\n\"be_greater_than_or_equal_to\": 500\n}\nresult = test(df, contract=[max_should(**keywords)])\n</code></pre>"},{"location":"possible_tests/#null_count_should","title":"null_count_should","text":"<p>Test that column null_count is within designated range</p> yamljsonpython <pre><code>be_exactly: 300\nbe_greater_than: 500\nbe_greater_than_or_equal_to: 500\nbe_less_than: 500\nbe_less_than_or_equal_to: 300\ncolumn: column_a\n</code></pre> <pre><code>{\n\"column\": \"column_a\",\n\"be_exactly\": 300,\n\"be_less_than\": 500,\n\"be_less_than_or_equal_to\": 300,\n\"be_greater_than\": 500,\n\"be_greater_than_or_equal_to\": 500\n}\n</code></pre> <pre><code>from wimsey import test\nfrom wimsey.tests import null_count_should\nkeywords = {\n\"column\": \"column_a\",\n\"be_exactly\": 300,\n\"be_less_than\": 500,\n\"be_less_than_or_equal_to\": 300,\n\"be_greater_than\": 500,\n\"be_greater_than_or_equal_to\": 500\n}\nresult = test(df, contract=[null_count_should(**keywords)])\n</code></pre>"},{"location":"possible_tests/#count_should","title":"count_should","text":"<p>Test that column count is within designated range</p> yamljsonpython <pre><code>be_exactly: 300\nbe_greater_than: 500\nbe_greater_than_or_equal_to: 500\nbe_less_than: 500\nbe_less_than_or_equal_to: 300\ncolumn: column_a\n</code></pre> <pre><code>{\n\"column\": \"column_a\",\n\"be_exactly\": 300,\n\"be_less_than\": 500,\n\"be_less_than_or_equal_to\": 300,\n\"be_greater_than\": 500,\n\"be_greater_than_or_equal_to\": 500\n}\n</code></pre> <pre><code>from wimsey import test\nfrom wimsey.tests import count_should\nkeywords = {\n\"column\": \"column_a\",\n\"be_exactly\": 300,\n\"be_less_than\": 500,\n\"be_less_than_or_equal_to\": 300,\n\"be_greater_than\": 500,\n\"be_greater_than_or_equal_to\": 500\n}\nresult = test(df, contract=[count_should(**keywords)])\n</code></pre>"},{"location":"possible_tests/#null_percentage_should","title":"null_percentage_should","text":"<p>Test that column null_percentage is within designated range</p> yamljsonpython <pre><code>be_exactly: 300\nbe_greater_than: 500\nbe_greater_than_or_equal_to: 500\nbe_less_than: 500\nbe_less_than_or_equal_to: 300\ncolumn: column_a\n</code></pre> <pre><code>{\n\"column\": \"column_a\",\n\"be_exactly\": 300,\n\"be_less_than\": 500,\n\"be_less_than_or_equal_to\": 300,\n\"be_greater_than\": 500,\n\"be_greater_than_or_equal_to\": 500\n}\n</code></pre> <pre><code>from wimsey import test\nfrom wimsey.tests import null_percentage_should\nkeywords = {\n\"column\": \"column_a\",\n\"be_exactly\": 300,\n\"be_less_than\": 500,\n\"be_less_than_or_equal_to\": 300,\n\"be_greater_than\": 500,\n\"be_greater_than_or_equal_to\": 500\n}\nresult = test(df, contract=[null_percentage_should(**keywords)])\n</code></pre>"},{"location":"possible_tests/#columns_should","title":"columns_should","text":"<p>Test column names match up with expected values</p> yamljsonpython <pre><code>be:\n- column_a\n- column_b\nhave:\n- column_a\nnot_have:\n- column_c\n</code></pre> <pre><code>{\n\"have\": [\n\"column_a\"\n],\n\"not_have\": [\n\"column_c\"\n],\n\"be\": [\n\"column_a\",\n\"column_b\"\n]\n}\n</code></pre> <pre><code>from wimsey import test\nfrom wimsey.tests import columns_should\nkeywords = {\n\"have\": [\n\"column_a\"\n],\n\"not_have\": [\n\"column_c\"\n],\n\"be\": [\n\"column_a\",\n\"column_b\"\n]\n}\nresult = test(df, contract=[columns_should(**keywords)])\n</code></pre>"},{"location":"possible_tests/#type_should","title":"type_should","text":"<p>Test column type matches up with expected value. Note that this will expect polars style types, although does not require that they be case sensitive. For example, if testing a pandas dataframe for integer type, specify \"int64\" rather than, say, \"int64[pyarrow]\" or otherwise.</p> yamljsonpython <pre><code>be: int64\nbe_one_of:\n- int64\n- float64\ncolumn: column_a\nnot_be: string\n</code></pre> <pre><code>{\n\"column\": \"column_a\",\n\"be\": \"int64\",\n\"not_be\": \"string\",\n\"be_one_of\": [\n\"int64\",\n\"float64\"\n]\n}\n</code></pre> <pre><code>from wimsey import test\nfrom wimsey.tests import type_should\nkeywords = {\n\"column\": \"column_a\",\n\"be\": \"int64\",\n\"not_be\": \"string\",\n\"be_one_of\": [\n\"int64\",\n\"float64\"\n]\n}\nresult = test(df, contract=[type_should(**keywords)])\n</code></pre>"},{"location":"possible_tests/#row_count_should","title":"row_count_should","text":"<p>Test that dataframe row count is within designated range</p> yamljsonpython <pre><code>be_exactly: 300\nbe_greater_than: 500\nbe_greater_than_or_equal_to: 500\nbe_less_than: 500\nbe_less_than_or_equal_to: 300\n</code></pre> <pre><code>{\n\"be_less_than\": 500,\n\"be_less_than_or_equal_to\": 300,\n\"be_greater_than\": 500,\n\"be_greater_than_or_equal_to\": 500,\n\"be_exactly\": 300\n}\n</code></pre> <pre><code>from wimsey import test\nfrom wimsey.tests import row_count_should\nkeywords = {\n\"be_less_than\": 500,\n\"be_less_than_or_equal_to\": 300,\n\"be_greater_than\": 500,\n\"be_greater_than_or_equal_to\": 500,\n\"be_exactly\": 300\n}\nresult = test(df, contract=[row_count_should(**keywords)])\n</code></pre>"}]}